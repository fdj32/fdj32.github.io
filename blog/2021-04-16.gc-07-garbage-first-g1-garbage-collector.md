[Garbage Collection Tuning](https://docs.oracle.com/en/java/javase/16/gctuning/introduction-garbage-collection-tuning.html)
===
[fdj32.github.io](https://fdj32.github.io)  
# 7. [垃圾优先垃圾收集器](https://docs.oracle.com/en/java/javase/16/gctuning/garbage-first-g1-garbage-collector1.html)
本章描述了垃圾优先垃圾收集器。
话题：
- <a href="#gc7a">垃圾优先垃圾收集器简介</a>
- <a href="#gc7b">启用G1</a>
- <a href="#gc7c">基本概念</a>
  - <a href="#gc7c1">堆布局</a>
  - <a href="#gc7c2">垃圾收集循环</a>
  - <a href="#gc7c3">垃圾收集暂停和收集集合</a>
- <a href="#gc7d">G1内部</a>
  - <a href="#gc7d1">调整Java堆大小</a>
    - <a href="#gc7d1a">调整仅年轻代大小</a>
    - <a href="#gc7d1b">调整空间回收阶段代大小</a>
  - <a href="#gc7d2">定期垃圾收集</a>
  - <a href="#gc7d3">决定初始化堆占用</a>
  - <a href="#gc7d4">标记</a>
  - <a href="#gc7d5">非常紧凑堆情况下的行为</a>
  - <a href="#gc7d6">巨大对象</a>
- <a href="#gc7e">G1 GC 人机默认值</a>
- <a href="#gc7f">与其他收集器比较</a>

## <span id="gc7a">垃圾优先垃圾收集器简介</span>
G1垃圾收集器是为多处理器大量内存设计的。它尝试以高概率达到垃圾收集暂停时间目标，同时无需多少配置达到高吞吐量目标。G1的目的是提供时延与吞吐量的最佳平衡点，使用具有以下特性的当前目标应用和环境。
- 堆内存达到数十GB或更多，且超过50%的Java堆被活动数据占据。
- 对象分配和升级的速率会随着时间的推移而显著变化。
- 堆内有大量碎片
- 可预见的暂停时间目标短于几百毫秒，避免垃圾收集长时间暂停。

G1在应用运行的同时也进行一部分工作。它交换应用程序可以使用的处理器资源，以缩短收集暂停时间。

这在应用程序运行时使用一个或多个活动的垃圾收集线程时最为明显。因此，与吞吐量收集器相比，虽然G1收集器的垃圾收集暂停时间通常要短得多，但应用程序吞吐量也往往略低。

G1是默认收集器。

G1收集器实现了高性能，并尝试通过以下几节中描述的几种方式来实现暂停时间目标。
## <span id="gc7b">启用G1</span>
垃圾第一垃圾收集器是默认的收集器，因此通常不必执行任何其他操作。您可以通过在命令行上提供-XX:+UseG1GC显式地启用它。
## <span id="gc7c">基本概念</span>
G1是一个分代的、增量的、并行的、主要是并发的、停止世界和疏散垃圾收集器，它监视每个停止世界暂停中的暂停时间目标。与其他收集器类似，G1将堆拆分为（虚拟的）年轻代和老年代。空间回收工作主要集中在年轻一代，在年轻一代中，这样做是最有效的，偶尔在老一代的空间回收。

一些操作总是在stop-the-world暂停中执行，以提高吞吐量。在应用程序停止时需要更多时间的其他操作（如全局标记等整个堆操作）与应用程序并行执行。为了使stop-the-world暂停时间短于空间回收时间，G1会逐步并行地执行空间回收。G1通过跟踪有关以前的应用程序行为和垃圾收集暂停的信息来构建相关成本的模型，从而实现可预测性。它使用这些信息来调整暂停中完成的工作的大小。例如，G1首先回收效率最高的区域中的空间（即大部分被垃圾填满的区域，因此命名为G1）。

G1主要通过疏散来回收空间：在选定的要收集的内存区域中找到的活动对象被复制到新的内存区域，并在这个过程中压缩它们。疏散完成后，先前由活动对象占用的空间将被应用程序重新分配。

垃圾第一收集器不是实时收集器。它试图在较长的时间内以高概率满足设定的暂停时间目标，但对于给定的暂停时间并不总是绝对确定的。
### <span id="gc7c1">堆布局</span>
G1将堆划分为一组大小相等的堆区域，每个区域都是虚拟内存的连续范围，如图9-1所示。区域是内存分配和内存回收的单位。在任何给定的时间，这些区域中的每一个都可以是空的（浅灰色），或者分配给特定的一代，年轻的或年老的。当内存请求传入时，内存管理器将释放可用区域。内存管理器将它们分配给一个年龄代，然后将它们作为空闲空间返回给应用程序，应用程序可以将自己分配到其中。

图 7-1 G1垃圾收集器堆布局

![Figure 7-1 G1 Garbage Collector Heap Layout](https://docs.oracle.com/en/java/javase/16/gctuning/img/jsgct_dt_004_grbg_frst_hp.png "Description of Figure 7-1 follows")

<a href="https://docs.oracle.com/en/java/javase/16/gctuning/img_text/jsgct_dt_004_grbg_frst_hp.html">图表描述</a>

年轻一代包含初生代（红色）和幸存者区域（红色带“S”）。这些区域提供了与其他收集器中相应的相邻空间相同的功能，不同的是，在G1中，这些区域通常以非连续模式在内存中布局。老地区（浅蓝色）组成了老年代。对于跨越多个区域的对象，老年代可能是巨大的（浅蓝色带“H”）。

一个应用程序总是分配到年轻代，也就是初生代，除了庞大的对象是直接分配为属于老年代。
### <span id="gc7c2">垃圾收集周期</span>
在高水平上，G1收集器在两个阶段之间交替。仅年轻阶段包含垃圾收集，这些垃圾收集会逐渐用老年代中的对象填充当前可用的内存。在空间回收阶段，G1除了处理年轻代之外，还会逐步回收老年代的空间。然后，循环以一个仅年轻阶段重新开始。

图7-2给出了有关此循环的概述，并举例说明了可能发生的垃圾收集暂停序列：

图 7-2 垃圾收集循环概述

![Figure 7-2 Garbage Collection Cycle Overview ](https://docs.oracle.com/en/java/javase/16/gctuning/img/jsgct_dt_001_grbgcltncyl.png "Description of Figure 7-2 follows")

<a href="https://docs.oracle.com/en/java/javase/16/gctuning/img_text/jsgct_dt_001_grbgcltncyl.html">图表描述</a>

以下列表详细描述了G1垃圾收集周期的阶段、暂停和阶段间的转换：
1. 仅年轻阶段：这个阶段从几个普通的年轻代收集开始，这些收集将对象提升到老年代。当老年代占用达到一定阈值时，即初始堆占用阈值，则开始仅年轻阶段与空间回收阶段之间的转换。此时，G1计划并发启动年轻收集，而不是常规的年轻收集。
- 并发开始：这种类型的收集除了执行正常的年轻代收集外，还启动标记过程。并发标记确定老年代区域中的所有当前可到达（活动）对象将保留用于以下空间回收阶段。当收集标记尚未完全完成时，可能会发生正常的年轻代收集。标记结束时有两个特别的停止世界暂停：标记和清理。
- 备注：此暂停完成标记本身，执行全局引用处理和类卸载，回收完全空的区域并清理内部数据结构。在Remark和Cleanup之间G1计算信息，以便以后能够同时回收选定老年代区域中的可用空间，这将在Cleanup 暂停中完成。
- 清理：此暂停决定是否将实际执行空间回收阶段。如果接下来是空间回收阶段，则仅年轻阶段将以单个Prepare Mixed 年轻代收集完成。
2. 空间回收阶段：这个阶段由多个混合收集组成，除了年轻代区域外，还可以疏散老年代区域集合中的活动对象。G1确定疏散更多的老年代区域，不会产生足够的自由空间，不值得为此花费努力，空间回收阶段就结束了。

在空间回收之后，收集周期将以另一个仅年轻阶段重新开始。作为备份，如果应用程序在收集活动信息时内存不足，G1会像其他收集器一样执行就地停止世界完全堆压缩（fullgc）。
### <span id="gc7c3">垃圾收集暂停和收集集合</span>
G1在停止世界暂停中执行垃圾收集和空间回收。活动对象通常从源区域复制到堆中的一个或多个目标区域，并调整对这些移动对象的现有引用。

对于非大型区域，对象的目标区域由该对象的源区域确定：
- 年轻代的对象（初生代和幸存者区）被复制到幸存者区或老年代区，这取决于他们的年龄。
- 老年代区的对象被复制到其他老年代区。

巨型区的对象被区别对待。G1只查看了它们的活跃度，如果它们不活跃，就收回它们所占据的空间。巨型区内的对象永远不会被G1移动。

收集集是要从中回收空间的源区域集合。根据垃圾收集的类型，收集集由不同类型的区域组成：
- 在仅年轻阶段，收集集仅由年轻代中的区域和具有潜在回收对象的巨型区组成。
- 在空间回收阶段，收集集由年轻代的区域、具有潜在回收对象的巨型区和收集集候选区域集中的一些老年代区域组成。

G1在并发循环期间准备收集集候选区域。在备注暂停期间，G1选择占用率较低的区域，这些区域包含大量可用空间。然后，在备注和清除暂停之间同时准备这些区域，以便以后收集。清理暂停根据其效率对该准备的结果进行排序。在随后的混合收集中，更有效的区域似乎需要更少的时间来收集，并且包含更多的可用空间。
## <span id="gc7d">G1内部</span>
本节介绍垃圾优先（G1）垃圾收集器的一些重要细节。
### <span id="gc7d1">调整Java堆大小</span>
G1在调整Java堆大小时遵循标准规则，使用-XX:InitialHeapSize作为最小Java堆大小，-XX:MaxHeapSize作为最大Java堆大小，-XX:MinHeapFreeRatio作为最小可用内存百分比，-XX:MaxHeapFreeRatio确定调整大小后最大可用内存百分比。G1收集器考虑在标记期间调整Java堆的大小，而整个GC只暂停。此进程可能会释放内存到操作系统或从操作系统分配内存。
#### <span id="gc7d1a">调整仅年轻代大小</span>
G1总是在一个正常的年轻代收集的末尾为下一个突变阶段确定年轻代的大小。这样，G1就可以满足使用-XX:MaxGCPauseTimeMillis和-XX:PauseTimeIntervalMillis根据对实际暂停时间的长期观察设定的暂停时间目标。它考虑到了类似规模的年轻一代需要多长时间撤离。这包括诸如在收集过程中必须复制多少对象，以及这些对象之间的相互联系等信息。

如果没有其他约束，则G1会在-XX:G1NewSizePercent和-XX:G1MaxNewSizePercent确定的值之间自适应地调整年轻代大小，以满足暂停时间的要求。有关如何修复长时间暂停的更多信息，请参阅垃圾优先垃圾收集器调整。

或者，-XX:NewSize和-XX:MaxNewSize可以分别用于设置最小和最大年轻代大小。

注：仅指定后面所述选项中的一个，就可以将年轻代大小精确地固定为分别用-XX:NewSize和-XX:MaxNewSize传递的值。这将禁用暂停时间控制。
#### <span id="gc7d1b">调整空间回收阶段代大小</span>
在空间回收阶段，G1尝试在一次垃圾回收暂停中最大化老年代中回收的空间量。年轻代的大小被设置为允许的最小值，通常由-XX:G1NewSizePercent决定。

在这个阶段的每个混合收集开始时，G1从收集集合候选集中选择一组区域以添加到收集集中。这组新的老年代区域由三部分组成：
- 确保疏散进度的最少一组老年代区域。这组旧的生成区域是由候选收集集中的区域数除以由-XX:g1mixedAccountTarget确定的空间回收阶段的长度来确定的。
- 如果G1预测在收集最小集之后将有剩余时间，则来自收集集候选集的其他老年代区域。老年代区域被添加，直到剩余时间的80%被预测使用。
- 一组可选的收集集区域，G1在其他两个部分被排空并且在该暂停中还有剩余时间之后逐渐排空。

在初始收集过程中收集前两组区域，并将可选收集集中的其他区域放入剩余的暂停时间。该方法在保证空间回收进度的同时，提高了保持暂停时间的概率，并由于对可选收集集的管理而使开销最小化。

当收集集候选区域中可回收的剩余空间量小于-XX:G1HeapWastePercent设置的百分比时，空间回收阶段结束。

有关G1将使用多少老年代区域以及如何避免长时间的混合收集暂停的更多信息，请参阅<a href="https://docs.oracle.com/en/java/javase/16/gctuning/garbage-first-garbage-collector-tuning.html">垃圾优先垃圾收集器调优</a>。
### <span id="gc7d2">定期垃圾收集</span>
如果由于应用程序不活动而长时间没有垃圾回收，VM可能会长时间保留大量未使用的内存，这些内存可能会在其他地方使用。为了避免这种情况，可以使用-XX:G1PeriodicGCInterval选项强制G1执行常规垃圾收集。此选项确定G1考虑执行垃圾回收的最小间隔（毫秒）。如果自上一次垃圾回收暂停以来经过了这段时间，并且没有进行并发循环，则G1会触发其他垃圾回收，并产生以下可能的影响：
- 在仅年轻阶段：G1使用并发开始暂停启动并发标记，或者，如果指定了-XX:-G1PeriodicGCInvokesConcurrent，则启动完整GC。
- 在空间回收阶段：G1继续空间回收阶段，触发适合当前进度的垃圾回收暂停类型。

-XX:G1PeriodicGCSystemLoadThreshold选项可用于优化是否触发垃圾收集：如果JVM主机系统（例如，容器）上的getloadavg() 调用返回的平均一分钟系统负载值高于此值，则不会运行定期垃圾收集。

有关定期垃圾收集的更多信息，请参见<a href="https://openjdk.java.net/jeps/346">jep346：立即从G1返回未使用的提交内存</a>。
### <span id="gc7d3">决定初始化堆占用</span>
初始堆占用百分比（IHOP）是触发初始标记收集的阈值，它定义为老年代大小的百分比。

默认情况下，G1通过观察打标所需的时间以及在打标周期中老年代通常分配的内存量，自动确定最佳IHOP。此功能称为自适应IHOP。如果此功能处于活动状态，则选项-XX:InitiatingHeapOccupencyPercent将初始值确定为当前老年代大小的百分比，只要没有足够的观察值来很好地预测初始堆占用阈值。使用选项XX:-g1useadaptivehop关闭G1的此行为。在本例中，-XX:InitiatingHeapOccupancePercent的值始终确定此阈值。

在内部，Adaptive IHOP尝试设置初始堆占用率，以便在老年代占用率为当前最大老年代大小减去作为额外缓冲区的-XX:g1heaperencepercent的值时，开始空间回收阶段的第一次混合垃圾回收。
### <span id="gc7d4">标记</span>
G1标记使用了一种称为Snapshot At The beging（SATB）的算法。当在标记开始时处于活动状态的所有对象被认为在标记的剩余时间处于活动状态时，它会在初始标记暂停时获取堆的虚拟快照。这意味着在标记过程中变为不活动（无法访问）的对象仍被视为活动对象，以便进行空间回收（除某些例外）。这可能会导致与其他收集器相比错误地保留一些额外的内存。然而，SATB可能在评论暂停期间提供更好的延迟。在该标记期间被认为过于保守的活动对象将在下一次标记期间被回收。有关标记问题的更多信息，请参阅<a href="https://docs.oracle.com/en/java/javase/16/gctuning/garbage-first-garbage-collector-tuning.html">垃圾优先垃圾收集器调优</a>。
### <span id="gc7d5">非常紧凑堆情况下的行为</span>
当应用程序保留了太多的内存，以至于疏散无法找到足够的空间进行复制时，就会发生疏散失败。疏散失败意味着G1试图通过将任何已经移动的对象保留在新位置来完成当前的垃圾收集，并且不复制任何尚未移动的对象，只调整对象之间的引用。疏散失败可能会带来一些额外的开销，但通常应该和其他年轻代收集一样快。本次垃圾收集后，由于疏散失败，G1将恢复正常使用，无需采取任何其他措施。G1假设疏散失败发生在接近垃圾收集结束时；也就是说，大多数对象已经被移动，并且还有足够的空间继续运行应用程序，直到标记完成和空间回收开始。

如果这个假设不成立，那么G1最终将安排一个完整的GC。这种类型的集合对整个堆执行就地压缩。这可能会很慢。

请参阅<a href="https://docs.oracle.com/en/java/javase/16/gctuning/garbage-first-garbage-collector-tuning.html">垃圾优先垃圾收集器调优</a>，以获取有关分配失败或在发出内存不足信号之前完全GC的问题的更多信息。
### <span id="gc7d6">巨大对象</span>
巨大对象是指大于或等于半个区域大小的对象。除非使用-XX:G1HEAPRINGSIZE选项设置，否则当前区域大小根据G1 GC部分的人机工程学默认值中的描述，根据人机工程学原理确定。

这些巨大对象有时会以特殊的方式处理：
- 在老年代中，每个巨大对象被分配为一系列连续的区域。对象本身的起点始终位于该序列中第一个区域的起点。在回收整个对象之前，序列最后一个区域中的任何剩余空间都将丢失以进行分配。
- 通常，大型对象只能在清除暂停期间标记结束时回收，如果无法访问，则在完全GC期间回收。但是，对于原始类型的数组（例如bool、所有类型的整数和浮点值）的庞大对象有一个特殊的规定。如果在任何类型的垃圾收集暂停时，大量对象没有被许多对象引用，那么G1会有机会尝试回收这些对象。默认情况下，此行为处于启用状态，但可以使用选项-XX:G1EagerReclaimHumongousObjects 禁用它。
- 巨大对象的分配可能会导致过早发生垃圾收集暂停。G1在每次大型对象分配时检查初始堆占用阈值，如果当前占用超过该阈值，则可能会立即强制初始标记年轻代收集。
- 这些巨大对象永远不会移动，甚至在完全GC期间也不会移动。这可能导致过早缓慢的完全GCs或意外的内存不足情况，因为区域空间的碎片化，剩余大量的可用空间。
## <span id="gc7e">G1 GC 人机默认值</span>
本主题概述了特定于G1的最重要的默认值及其默认值。它们粗略地概述了使用G1的预期行为和资源使用情况，没有任何附加选项。

表 7-1 G1 GC 人机默认值
| 选项和默认值 | 描述 |
| --- | --- |
| -XX:MaxGCPauseMillis=200 | 最大暂停时间的目标。 |
| -XX:GCPauseTimeInterval=< ergo > | 最大暂停时间间隔的目标。默认情况下，G1不设置任何目标，允许G1在极端情况下连续执行垃圾收集。 |
| -XX:ParallelGCThreads=< ergo > | 垃圾回收暂停期间用于并行工作的最大线程数。这是根据VM以以下方式运行的计算机的可用线程数得出的：如果进程可用的CPU线程数小于或等于8，则使用该值。否则，将大于最终线程数的八分之五的线程相加。在每次暂停开始时，使用的最大线程数进一步受到最大总堆大小的限制：G1在Java堆容量的-XX:HeapSizePerGCThread数量中不会使用多个线程。 |
| -XX:ConcGCThreads=< ergo > | 用于并行工作的最大线程数。默认情况下，该值为-XX:ParallelGCThreads除以4。 |
| -XX:+G1UseAdaptiveIHOP -XX:InitiatingHeapOccupancyPercent=45 | 控制初始堆占用率的默认值表明，启用了该值的自适应确定，并且对于前几个收集周期，G1将使用老年代的45%的占用率作为标记开始阈值。 |
| -XX:G1HeapRegionSize=< ergo > | 堆区域的大小。默认值基于最大堆大小，并计算为渲染大约2048个区域。大小必须是2的幂，有效值为1到32 MB。 |
| -XX:G1NewSizePercent=5 -XX:G1MaxNewSizePercent=60 | 年轻代的总大小，在这两个值之间变化，占当前使用的Java堆的百分比。 |
| -XX:G1HeapWastePercent=5 | 允许的未回收空间在收集集合候选空间中的占比百分比。如果收集集候选中的可用空间低于该空间，G1将停止空间回收阶段。 |
| -XX:G1MixedGCCountTarget=8 | 在许多收集中，空间回收阶段的预期长度。 |
| -XX:G1MixedGCLiveThresholdPercent=85 | 在此空间回收阶段，不会收集活动对象占用率高于此百分比的老年代区域。 |
注：< ergo > 表示实际值取决于环境，由人机工程学确定。
## <span id="gc7f">与其他收集器比较</span>
这是G1和其他收集器之间主要区别的总结：
- 并行GC只能作为一个整体压缩和回收老年代的空间。G1递增地将此工作分发到多个更短的收集中。这大大缩短了暂停时间，但可能会牺牲吞吐量。
- G1同时执行老年代空间回收的一部分。
- G1可能表现出比上述收集器更高的开销，由于其并发性而影响吞吐量。
- ZGC的目标是非常大的堆，旨在以更高的吞吐量成本提供更小的暂停时间。

由于它的工作方式，G1有一些独特的机制来提高垃圾收集效率：
- G1可以在任何收集过程中回收一些完全空的、大面积的老年代。这可以避免许多其他不必要的垃圾收集，无需花费太多精力即可释放大量空间。
- G1可以选择同时尝试删除Java堆上的重复字符串。

始终启用从旧代回收空的大型对象。您可以使用-XX:-G1EagerReclaimHumongousObjects 选项禁用此功能。默认情况下禁用字符串重复数据消除。您可以使用-XX:+G1EnableStringDeduplication 选项启用它。