[Garbage Collection Tuning](https://docs.oracle.com/en/java/javase/16/gctuning/introduction-garbage-collection-tuning.html)
===
[fdj32.github.io](https://fdj32.github.io)  
# 10. [其他考虑](https://docs.oracle.com/en/java/javase/16/gctuning/other-considerations.html)
本节介绍影响垃圾收集的其他情况。

话题:
- <a href="#gc10a">终结和弱、软、虚引用</a>
- <a href="#gc10b">显式垃圾回收</a>
- <a href="#gc10c">软引用</a>
- <a href="#gc10d">类元数据</a>

## <span id="gc10a">终结和弱、软、虚引用</span>
一些应用程序通过使用终结和弱引用、软引用或虚引用与垃圾回收进行交互。

这些特性可以在Java编程语言级别创建性能构件。这方面的一个例子是依赖于终结来关闭文件描述符，这使得外部资源（描述符）依赖于垃圾收集的及时性。依靠垃圾收集来管理内存以外的资源几乎总是一个坏主意。

请参阅<a href="http://www.devx.com/Java/Article/30192">如何处理Java终结的内存保留问题</a>，其中深入讨论了终结的一些陷阱以及避免这些陷阱的技术。 
## <span id="gc10b">显式垃圾回收</span>
应用程序与垃圾收集交互的另一种方式是显示调用 System.gc() 使用完全垃圾回收.

这可能会在不必要时（例如，当一个小型收集就足够时）强制执行一个大型收集，因此通常应该避免。显式垃圾回收的性能影响可以通过使用标志 -XX:+DisableExplicitGC 禁用它们来衡量，这会导致VM忽略调用 System.gc().

显式垃圾收集最常见的用法之一发生在远程方法调用（RMI）的分布式垃圾收集（DGC）中。使用RMI的应用程序引用其他虚拟机中的对象。在这些分布式应用程序中，如果不偶尔调用本地堆的垃圾收集，则无法收集垃圾，因此RMI会定期强制执行完全收集。可以使用属性控制这些收集的频率，如下例所示： 
```
java -Dsun.rmi.dgc.client.gcInterval=3600000
    -Dsun.rmi.dgc.server.gcInterval=3600000 ...
```
此示例指定每小时一次的显式垃圾收集，而不是每分钟一次的默认速率。但是，这也可能导致一些对象需要更长的时间才能回收。这些属性可以设置为Long.MAX_VALUE 如果不希望DGC活动的及时性有一个上界，那么就使得显式收集之间的时间实际上是无限的。
## <span id="gc10c">软引用</span>
软引用在服务器虚拟机中比在客户机中保持活动的时间更长。

清除速率可以通过命令行选项 -XX:SoftRefLRUPolicyMSPerMB=&lt;N&gt; 来控制，该选项指定堆中每兆可用空间的软引用将保持活动（一旦软引用不再强可访问）的毫秒数。默认值为1000ms/megabyte，这意味着软引用在堆中的每兆可用空间中（在收集到对对象的最后一个强引用之后）将保留1秒。这是一个近似的数字，因为软引用仅在垃圾收集期间清除，垃圾收集可能偶尔发生。 
## <span id="gc10d">类元数据</span>
