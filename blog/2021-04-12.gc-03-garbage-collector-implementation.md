[Garbage Collection Tuning](https://docs.oracle.com/en/java/javase/16/gctuning/introduction-garbage-collection-tuning.html)
===
[fdj32.github.io](https://fdj32.github.io)  
# 3. [垃圾收集器实现](https://docs.oracle.com/en/java/javase/16/gctuning/garbage-collector-implementation.html)
Java SE平台的一项实力在于它将内存分配和垃圾收集的复杂性与开发者隔离。

但是，当垃圾收集成为主要的瓶颈，理解它的实现的方方面面就显得很有用处。垃圾收集器假设应用使用对象的方式，这些会反映在可优化的参数中，可以被调整以提升性能，而不牺牲抽象的力量。

话题：
- <a href="#gc3a">分代垃圾收集</a>
- <a href="#gc3b">分代</a>
- <a href="#gc3c">性能考虑</a>
- <a href="#gc3d">吞吐量与空间量衡量</a>

## <span id="#gc3a">分代垃圾收集</span>
一个对象当它不再被应用中的任何活动对象的引用访问到，就被认为是垃圾，它的内存可被JVM重用。

一个理论上的，最直接的垃圾收集算法是，当它运行时，迭代所有可访问到的对象。任何剩余的对象就会被认为是垃圾，这个方法所花费的时间是与活动对象个数成正比的，这是维护大量活动对象的大型应用所禁止的。

Java热点虚拟机合并多个垃圾收集算法，除ZGC外都使用了一种被称为分代收集的技术。幼稚的垃圾收集每次都会检查堆中所有活动对象，分代收集则从大多数应用中，探索多个经验观测特性，来最小化回收无用对象(垃圾)所做的工作。这些观测特性中，最重要的是弱世代假说，它说明了绝大多数对象都只生存了很短的时间。

图3-1的蓝色区域是对象生存时间的一个典型分布。x轴表示对象时间以字节分配为衡量，y轴上的字节总数是相应生存时间内的总字节数。左侧的尖峰表示了对象在被分配后很快就能被回收(换个说法就是死了)，例如迭代器对象一般只在一个简单循环里面是活着的。

图 3-1 对象生存时间的典型分布

![Figure 3-1 Typical Distribution for Lifetimes of Objects](https://docs.oracle.com/en/java/javase/16/gctuning/img/jsgct_dt_003_alc_vs_srvng.png "Description of Figure 3-1 follows")

<a href="https://docs.oracle.com/en/java/javase/16/gctuning/img_text/jsgct_dt_003_alc_vs_srvng.html">图表描述</a>

有些对象却是活得很久，所以它的分布会一直延伸到右侧。例如有一些对象从初始化就被分配，一直活到虚拟机退出。在这两个极端之间，是那些活在即时计算中的对象，例如图中右侧隆起的块。一些应用会有非常不同的分布，但是很大一部分都与这个常见分布相似。集中注意力在一个重要事实上，大多对象很快就死了，高效回收可能实现。
## <span id="#gc3b">分代</span>

## <span id="#gc3c">性能考虑</span>
## <span id="#gc3d">吞吐量与空间量衡量</span>
