[Garbage Collection Tuning](https://docs.oracle.com/en/java/javase/16/gctuning/introduction-garbage-collection-tuning.html)
===
[fdj32.github.io](https://fdj32.github.io)  
# 3. [垃圾收集器实现](https://docs.oracle.com/en/java/javase/16/gctuning/garbage-collector-implementation.html)
Java SE平台的一项实力在于它将内存分配和垃圾收集的复杂性与开发者隔离。

但是，当垃圾收集成为主要的瓶颈，理解它的实现的方方面面就显得很有用处。垃圾收集器假设应用使用对象的方式，这些会反映在可优化的参数中，可以被调整以提升性能，而不牺牲抽象的力量。

话题：
- <a href="#gc3a">分代垃圾收集</a>
- <a href="#gc3b">分代</a>
- <a href="#gc3c">性能考虑</a>
- <a href="#gc3d">吞吐量与空间量衡量</a>

## <span id="#gc3a">分代垃圾收集</span>
一个对象当它不再被应用中的任何活动对象的引用访问到，就被认为是垃圾，它的内存可被JVM重用。

一个理论上的，最直接的垃圾收集算法是，当它运行时，迭代所有可访问到的对象。任何剩余的对象就会被认为是垃圾，这个方法所花费的时间是与活动对象个数成正比的，这是维护大量活动对象的大型应用所禁止的。

Java热点虚拟机合并多个垃圾收集算法，除ZGC外都使用了一种被称为分代收集的技术。幼稚的垃圾收集每次都会检查堆中所有活动对象，分代收集则从大多数应用中，探索多个经验观测特性，来最小化回收无用对象(垃圾)所做的工作。这些观测特性中，最重要的是弱世代假说，它说明了绝大多数对象都只生存了很短的时间。

图3-1的蓝色区域是对象生存时间的一个典型分布。x轴表示对象时间以字节分配为衡量，y轴上的字节总数是相应生存时间内的总字节数。左侧的尖峰表示了对象在被分配后很快就能被回收(换个说法就是死了)，例如迭代器对象一般只在一个简单循环里面是活着的。

图 3-1 对象生存时间的典型分布

![Figure 3-1 Typical Distribution for Lifetimes of Objects](https://docs.oracle.com/en/java/javase/16/gctuning/img/jsgct_dt_003_alc_vs_srvng.png "Description of Figure 3-1 follows")

<a href="https://docs.oracle.com/en/java/javase/16/gctuning/img_text/jsgct_dt_003_alc_vs_srvng.html">图表描述</a>

有些对象却是活得很久，所以它的分布会一直延伸到右侧。例如有一些对象从初始化就被分配，一直活到虚拟机退出。在这两个极端之间，是那些活在即时计算中的对象，例如图中右侧隆起的块。一些应用会有非常不同的分布，但是很大一部分都与这个常见分布相似。集中注意力在一个重要事实上，大多对象很快就死了，高效回收可能实现。
## <span id="#gc3b">分代</span>
优化这个场景，内存被分代管理(内存池持有不同年龄的对象)，垃圾收集发生在每个分代中，当这一代被填满。

绝大多数对象被分配在一个池子里，这个池子用于存储年轻代对象，大多数对象会在池子里死去。当年轻代被填满时，它将导致在池子里发生小型收集，只有年轻代对象被收集。其他年代的不会被回收。这样的开销是，与当前活动对象成一阶正比将会被收集，全是年轻代的死对象被快速收集。通常在每次小型回收中，从年轻代生存下来的对象会被移动到老年代。最终，老年代也被填满，必须被收集，会发生大型收集，整个堆都会被收集。大型收集通常比小型收集持续更长时间，因为牵涉到更大数目的对象。图 3-2 显示了串行垃圾收集器中默认分代排列。

图 3-2 串行垃圾收集器中默认分代排列

![Figure 3-1 Typical Distribution for Lifetimes of Objects](https://docs.oracle.com/en/java/javase/16/gctuning/img/jsgct_dt_001_armgnt_gn_new.png "Description of Figure 3-2 follows")

<a href="https://docs.oracle.com/en/java/javase/16/gctuning/img_text/jsgct_dt_001_armgnt_gn_new.html">图表描述</a>

在最开始，Java热点虚拟机在地址空间上预留整个Java堆，但如不需要，就不给它分配任何物理内存。这覆盖Java堆的整个地址空间被逻辑分成年轻代和老年代。为对象内存所预留的整个地址空间能被分成年轻代和老年代。

年轻代包含初生代和两个幸存者空间，大多数对象在初生代中分配。一个幸存者空间在任何时间都是空的，用来放初生代活动对象，另一个幸存者空间用来放垃圾收集后初生代幸存者，垃圾收集后，初生代和源幸存者空间被清空，在下一次垃圾收集中，这两个幸存者空间会互换。一个最近被填充的幸存者空间，是一个活动对象来源，会被复制到另一个幸存者空间。对象会以这种方式在幸存者空间中来回复制直到他们被复制的次数达到上限，或者已经没有足够空间使用。这些对象将会被复制到老年代中，这个过程叫做老龄化。
## <span id="#gc3c">性能考虑</span>


## <span id="#gc3d">吞吐量与空间量衡量</span>
