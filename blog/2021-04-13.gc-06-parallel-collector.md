[Garbage Collection Tuning](https://docs.oracle.com/en/java/javase/16/gctuning/introduction-garbage-collection-tuning.html)
===
[fdj32.github.io](https://fdj32.github.io)  
# 6. [并行收集器](https://docs.oracle.com/en/java/javase/16/gctuning/parallel-collector1.html)
并行收集器（在这里也被引用为吞吐量收集器）是一个分代收集器，与串行收集器类似。串行收集器和并行收集器的主要区别是，并行收集器有多个线程被用于加速垃圾收集。

并行收集器使用命令行选项 -XX:+UseParallelGC 开启。默认地，使用这个选项，小型和大型收集都是并行运行，极大地降低垃圾收集的开销。

话题：
- <a href="#gc6a">并行收集器的垃圾收集线程数</a>
- <a href="#gc6b">并行收集器的分代安排</a>
- <a href="#gc6c">并行收集器的人机设计</a>
  - <a href="#gc6c1">设置并行收集器行为的选项</a>
  - <a href="#gc6c2">并行收集器目标的优先级</a>
  - <a href="#gc6c3">并行收集器分代容量调整</a>
  - <a href="#gc6c4">并行收集器默认堆容量</a>
    - <a href="#gc6c4a">并行收集器的初始堆容量和最大堆容量说明</a>
- <a href="#gc6d">并行收集器时间过长和内存溢出错误</a>
- <a href="#gc6e">衡量并行收集器</a>

## <span id="gc6a">并行收集器的垃圾收集线程数</span>
在一台有< N >(N>8)个硬件线程的机器上，并行收集器使用< N >的固定一部分作为垃圾收集线程数。

当< N >比较大时，这个部分接近于5/8。当< N >小于8，这个数取< N >。在已选平台上，这个比例掉到5/16。这个指定的垃圾收集器线程能被调整，使用一个命令行选项(后续会介绍到)。在一台只有一个处理器的主机上，并行收集器可能不会表现得像串行收集器那样，因为并行处理需要一部分开销(例如同步)。但是，使用中等容量或大容量堆运行应用，在双处理器主机上，它通常会比串行收集器表现的稍好。通常在多余两个处理器的主机上，表现得极大超越串行收集器。

并行收集器线程数可以通过命令行选项 -XX:ParallelGCThreads=< N >控制。如果你使用命令行选项优化堆，那么要实现好的性能，并行收集器所需的堆与串行收集器所需的堆一样。但是，启用并行收集器会使收集暂停更短，因为多个垃圾收集器线程会参与到小型收集中，在收集过程中，从年轻代提升到老年代可能会产生一些碎片。参与到小型收集的每个垃圾收集线程预留一部分老年代和一部分可用空间作为这些提升缓冲区，会导致碎片效应。减少垃圾收集线程数并提高老年代容量会减少这种碎片效应。
## <span id="gc6b">并行收集器的分代安排</span>
并行收集器的分代安排不太一样。
图 6-1 并行收集器的分代安排

![Figure 6-1 Arrangement of Generations in the Parallel Collector](https://docs.oracle.com/en/java/javase/16/gctuning/img/jsgct_dt_002_armgnt_gn_pl_new.png "Description of Figure 6-1 follows")


<a href="https://docs.oracle.com/en/java/javase/16/gctuning/img_text/jsgct_dt_002_armgnt_gn_pl_new.html">图表描述</a>

## <span id="gc6c">并行收集器的人机设计</span>
当使用-XX:+UseParallelGC选择并行收集器，它启用了一种自动优化方法，允许你设置行为，而不是设置分代容量和其他底层优化细节。
### <span id="gc6c1">设置并行收集器行为的选项</span>
你可以设定垃圾收集最大暂停时间，吞吐量，空间量（堆容量）。
- 垃圾收集最大暂停时间：最大暂停时间目标时通过命令行选项 -XX:MaxGCPauseMillis=< N >设置。这被解释为暗示暂停时间少于< N >毫秒或更少是期望的。默认地，没有最大暂停时间目标。如果最大暂停目标被设定，可以调整堆容量和垃圾收集的其他相关参数，使垃圾收集暂停时间短于给定时间。但是，想要达到的暂停时间目标并不是总能达到。这些调整可能会导致垃圾收集器降低应用的全局吞吐量。
- 吞吐量：吞吐量目标是以花费在垃圾收集上的时间与垃圾收集以外的时间（应用时间）比所衡量的，这个目标时用命令行选项-XX:GCTimeRatio=< N >设定，意思是垃圾收集时间与应用时间比为1:(1+< N >)。例如，-XX:GCTimeRatio=19 设置了目标为1/20 或 5%的总时间用于垃圾收集。默认值是99，也就是设置的目标时将1%的时间用于垃圾收集。
- 空间量：堆空间量最大值是用选项 -Xmx< N >设置的。此外，收集器有一个隐含目标，当其他目标达成之后，将尽可能减小堆容量。
### <span id="gc6c2">并行收集器目标的优先级</span>
目标分别是：最大暂停时间目标，吞吐量目标，最小空间量目标，以此顺序排列。

最大暂停时间首先被满足，只有当它被满足才去考虑吞吐量目标，与此一致，只有当前两个目标达成之后才去考虑空间量目标。
### <span id="gc6c3">并行收集器分代容量调整</span>
收集器的统计数据诸如平均暂停时间，会在每次收集完成之后更新。

此时将会检查是否满足这些目标，以及对年龄代容量的任何调整将在此时做出。但是显示垃圾收集是个例外，例如，调用 System.gc() 将不会保存统计数据或调整年龄代容量。

年龄代的扩容或缩容是以年龄代容量的固定百分比向上或乡下调整到合适的大小。扩容和缩容的比例不同。默认地，年龄代扩容以20%，缩容以5%。扩容百分比可以被命令行选项 -XX:YoungGenerationSizeIncrement=< Y > 设置年轻代增长比例和 -XX:TenuredGenerationSizeIncrement=< T > 设置老年代增长比例。一个年龄代的收缩可以被命令行 -XX:AdaptiveSizeDecrementScaleFactor=< D > 调整。如果增长比为X%，则收缩比为(X/D)%。

如果收集器从一开始就决定扩容，那将有一个额外的增长比，但是这个增长比会慢慢衰减，不会长期存在。目的是优化优化启动性能，但对缩容没有这种功能。

如果最大暂停时间目标没有被满足，那么一次将只有一个年龄代会被收缩。如果两个年龄代的暂停时间都超出了目标，那么暂停时间更长的那个将会被首先收缩。

如果吞吐量目标没有被满足，那么年龄代的容量将会增长。每个都以它对总垃圾收集时间的贡献按比例增长。例如，如果年轻代垃圾收集占总收集时间的25%，且容量总共增长20%，那么年轻代将增长5%。
### <span id="gc6c4">并行收集器默认堆容量</span>
除非初始化和最大堆容量是用命令行选项指定，它们将会基于机器内存计算得出。默认最大堆内存为1/4物理内存，初始化堆容量是1/16物理内存。分配给年轻代的总量最多是总量的1/3。
#### <span id="gc6c4a">并行收集器的初始堆容量和最大堆容量说明</span>
你可以通过 -Xms 设置初始堆容量，-Xmx设置最大堆容量。

如果你知道你的应用需要多少堆容量才能很好地工作，那你可以这个这两个值为相同。如果你不知道，那么JVM将会使用初始化堆容量启动，增长堆容量直到它找到性能与堆容量使用之间的平衡点。

其他的参数和选项会影响到默认。验证你的默认值，可以使用-XX:+PrintFlagsFinal 选项，在输出中查找 -XX:MaxHeapSize。例如，在linux上运行下面的命令：
```
java -XX:+PrintFlagsFinal <GC options> -version | grep MaxHeapSize
```
## <span id="gc6d">并行收集器时间过长和内存溢出错误</span>
当垃圾收集花费太多时间时，并行收集器会抛出一个OOME。

如果超出98%的总时间被花费在垃圾收集上，只有2%的堆被回收，那么抛出一个OOME。这项特性被设计用于避免应用因为堆太小而浪费时间毫无进展。如必要，这个特性可以被关闭，在命令行加上 -XX:-UseGCOverheadLimit即可。
## <span id="gc6e">衡量并行收集器</span>
并行收集器的日志输出与串行基本一致，毋庸赘述。