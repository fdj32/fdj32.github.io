[Garbage Collection Tuning](https://docs.oracle.com/en/java/javase/16/gctuning/introduction-garbage-collection-tuning.html)
===
[fdj32.github.io](https://fdj32.github.io)  
# 4. [影响垃圾收集性能的因素](https://docs.oracle.com/en/java/javase/16/gctuning/factors-affecting-garbage-collection-performance.html)
影响垃圾收集性能的两个最重要的因素是可用总内存和专供年轻代的堆内存比例。

话题：
- <a href="#gc4a">堆总量</a>
  - <a href="#gc4a1">堆选项影响年代容量</a>
  - <a href="#gc4a2">堆容量默认选项值</a>
  - <a href="#gc4a3">通过最小化Java堆容量来节约动态空间量</a>
- <a href="#gc4b">年轻代</a>
  - <a href="#gc4b1">年轻代容量选项</a>
  - <a href="#gc4b2">幸存者空间容量</a>

## <span id="gc4a">堆总量</span>

影响垃圾收集性能最重要的因素是可用总内存。因为收集发生在年代区被填满，吞吐量与可用内存量成反比。

注意：下面的讨论是关于堆扩容和缩容，堆布局，以及一个以默认值使用串行收集器的例子。其他的收集器也使用类似机制，这里展现的细节可能不会应用到其他收集器上。请参考其他收集器相应话题的类似信息。

### <span id="gc4a1">堆选项影响年代容量</span>

有一系列的参数影响年代容量，看图 4-1 显示了堆区已提交空间和虚拟空间的不同点。在虚拟机初始化时，整个堆区空间都是预留的。预留空间容量可以使用选项 -Xmx 设置。如果 -Xms 的参数值小于 -Xmx 的参数值，并不是所有的预留空间都被立即提交给虚拟机。在图中未提交空间被标为"virtual"。堆区的不同部分，包括老年代和年轻代，可以根据需要增长到虚拟空间的极限。

有些参数是堆区的一个部分相对于另一个部分的比值。例如，参数 -XX:NewRatio 表示老年代是年轻代的倍数。

图 4-1 堆选项


![Figure 4-1 Heap Options](https://docs.oracle.com/en/java/javase/16/gctuning/img/jsgct_dt_006_prm_gn_sz_new.png "Description of Figure 4-1 follows")

<a href="https://docs.oracle.com/en/java/javase/16/gctuning/img_text/jsgct_dt_006_prm_gn_sz_new.html">图表描述</a>

### <span id="gc4a2">堆容量默认选项值</span>

默认情况下，虚拟机在每次收集时对堆进行扩容和缩容，努力保持每个年代中的空闲空间与活动对象直接的比例在一个相应区间中。

这个目标区间是使用一些百分比选项设置 -XX:MinHeapFreeRatio=<nnn> 和 -XX:MaxHeapFreeRatio=<mmm>，总容量是最少 -Xms<min> 最多 -Xmx<max>。

通过这些选项，如果一个年代内的空闲空间百分比下降到40%，那么这个年代将扩展去保持40%空闲空间，直至当前年代允许的最大值。类似地，如果空闲空间超出70%，那么当前年代收缩来保持70%空间是空闲的，直至当前年代允许的最小值。

这种预测原先使用在Java SE的并行收集器中，现在已经在所有的垃圾收集器中使用了。这个预测的一部分是64位平台的最大堆容量的上限。参考 <a href="https://docs.oracle.com/en/java/javase/16/gctuning/parallel-collector1.html">并行收集器默认堆容量</a> 在客户端 JVM中有一个类似的预测，相比于服务器JVM，它的堆容量最大值更小。

以下是服务器应用堆容量的通用指导：
- 除非你在暂停上遇到问题，给虚拟机授予尽可能多的内存。默认容量通常都太小。
- 设置 -Xms 和 -Xmx 为相同的值，从虚拟机中删除更重要的容量配置，可提升预测性。但是，虚拟再也无法对你做出的差劲选择进行补救。
- 通常，当你增加处理器个数则相应增加内存，因为分配内存可以是并行的。

### <span id="gc4a3">通过最小化Java堆容量来节约动态空间量</span>
如果你需要为你的应用最小化动态内存空间量(执行程序消费的RAM最大值)，那么你可以通过最小化Java堆容量实现。Java SE 嵌入式应用可能要求这样做。

最小化Java堆容量可以通过降低选项值 -XX:MaxHeapFreeRatio(默认70%)和 -XX:MinHeapFreeRatio(默认40%)。降低 -XX:MaxHeapFreeRatio 到10%和 -XX:MinHeapFreeRatio以及显示出可以成功地减少堆容量且不会有太大的性能损失。但是，根据你的应用不同，结果也差异很大。在这些参数上使用不同的值直到他们尽可能低，而应用仍然能够保持可接受的性能。

另外，你可以设置 -XX:-ShrinkHeapInSteps，它可以立即降低Java堆到目标容量(通过 -XX:MaxHeapFreeRatio 设置)。使用这个配置，你可能遇到性能降级。默认地，随着Java运行时将堆容量持续降低到目标容量，进程需要多次垃圾收集。

## <span id="gc4b">年轻代</span>
排在可用内存总量之后，影响垃圾收集性能的第二重要因素是堆区指定给年轻代的比例。

年轻代越大，小型收集发生的越少。但是对于一个固定的堆容量，一个更大的年轻代，意味着更小的年老代，则导致更为频繁的大型收集。最佳值依赖于应用分配的对象的生存时间分布。
### <span id="gc4b1">年轻代容量选项</span>
默认地，年轻代容量是通过选项-XX:NewRatio控制。

例如，设置 -XX:NewRatio=3意味着年轻代与年老代的比例是1:3。换句话说，初生代和幸存者代空间的总量是堆总内存的1/4。

选项 -XX:NewSize 和 -XX:MaxNewSize 分别设置年轻代容量的最低和最高值。给它们设置相同值会固定年轻代的比例，就像设置 -Xms 和 -Xmx 为相同值会固定住堆总内存。这对优化年轻代很有用，它比用整数倍设置 -XX:NewRatio 更细粒度。
### <span id="gc4a3">幸存者空间容量</span>
你能使用选项 -XX:SurvivorRatio 来优化幸存者空间的容量，但是这通常对于性能并不重要。

例如，-XX:SurvivorRatio=6 设置一个幸存者代空间与初生代的比例为1:6。换句话说，每个幸存者代空间是初生代容量的1/6，也就是年轻代总容量的1/8【1/(1+1+6)】，而不是1/7，因为有两个幸存者代。

如果幸存者代空间太小，那么复制的集合就会超限，直接被放入年老代。如果幸存者代太大，那么他们经常是无用的被空置。在每次垃圾收集中，虚拟机选择一个阈值，限制一个对象能被幸存者代来回复制的次数，超出放入年老代。这个阈值被用来保持幸存者代半满状态。你可以使用日志配置-Xlog:gc,age，此配置可以显示这个阈值和新一代对象的年龄。这对观察应用的生存时间分布有用。

表 4-1 幸存者空间容量的默认选项值

| 选项 | 默认值 |
| --- | --- |
| -XX:NewRatio | 2 |
| -XX:NewSize | 1310MB |
| -XX:MaxNewSize | not limited |
| -XX:SurvivorRatio | 8 |

年轻代的最大容量是通堆总容量最大值和 -XX:NewRatio 参数计算出来的。-XX:MaxNewSize 参数的默认值 "not limited"意味着这个计算出的值不会被-XX:MaxNewSize限制，除非在命令行明确用这个参数设置一个值进行限制。

以下是给服务器应用的通用指导：
- 首先决定在你力所能及的情况下给虚拟机提供最大堆的容量。然后，根据年轻代容量绘制你的性能指标来寻找最优设置。
  - 注意最大堆容量应该总是小于安装在机器上总内存，以避免过多的页访问错误和抖动。
- 如果堆总容量固定，那么增加年轻代容量就需要降低老年代容量。保持老年代容量足够大，来持有应用在任意时刻所使用的活动对象以及大约10%到20%或更多的闲置空间。
- 受制于先前在老年代上的约束
  - 授予大量内存给年轻代
  - 当你增加处理器数目时，增加年轻代的容量，因为分配内存可以是并行的。