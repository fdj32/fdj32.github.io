[Garbage Collection Tuning](https://docs.oracle.com/en/java/javase/16/gctuning/introduction-garbage-collection-tuning.html)
===
[fdj32.github.io](https://fdj32.github.io)  
# 5. [可用的收集器](https://docs.oracle.com/en/java/javase/16/gctuning/available-collectors.html)
迄今为止我们讨论的都是串行收集器。Java热点虚拟机包含3种不同的收集器，每种都有不同的性能特点。

话题：
- <a href="#gc5a">串行收集器</a>
- <a href="#gc5b">并行收集器</a>
- <a href="#gc5c">垃圾优先收集器</a>
- <a href="#gc5d">Z收集器</a>
- <a href="#gc5e">选择一个收集器</a>

## <span id="gc5a">串行收集器</span>
串行收集器使用一个线程来完成所有的垃圾收集工作，这就使它相对高效，因为没有线程间通信开销。

这是单处理器机器的最佳搭档，因为它无法从多处理器硬件受益，虽然它对于多处理器上的一些只有很少数据集(最多100MB)的应用有用。串行收集器在某些硬件和操作系统配置上被默认选择，或者可以被明确指定，通过选项 -XX:+UseSerialGC。
## <span id="gc5b">并行收集器</span>
并行收集器也以吞吐量收集器为人所知，它也是一个分代收集器，类似于串行收集器。它们主要的差异在于并行收集器有很多的线程用来加速垃圾收集。

并行收集器是为有中等数量或大量数据集的运行在多处理器或多线程硬件上的应用设计的。你可以明确使用它，通过选项 -XX:+UseParallelGC。

并行压缩是一个特性，是让并行收集器用来实施并行大型收集的。如果没有它，大型收集是使用一个线程进行的，这会极大地限制可扩展性。并行压缩被默认开启，如果有了选项 -XX:+UseParallelGC 。你也可以关闭它，使用选项 -XX:-UseParallelOldGC。
## <span id="gc5c">垃圾优先收集器</span>
G1是一个并发收集器。大多数情况下，并发收集器会在应用运行时并发执行很多高消耗的工作。这个收集器被设计为可从小型机器进而扩展到多处理器大量内存的大型机器。它提供了高概率实现停止时间目标的能力，它可达到高吞吐量。

G1被大多数硬件和操作系统配置默认选择，或者用 -XX:+UseG1GC 明确选定。
## <span id="gc5d">Z收集器</span>
## <span id="gc5e">选择一个收集器</span>